% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/command.R
\name{tryCapture}
\alias{tryCapture}
\title{Evaluate an expression with formal capturing and logging or webhook reporting
of the result, including warnings and errors with a stack trace.}
\usage{
tryCapture(expr, args = NULL)
}
\arguments{
\item{expr}{An expression for evaluation.  Any variables required by the
expression can be passed as command line arguments.  If reporting to a
.json file or webhook is requested, \code{expr} must return an object that
can be converted to JSON using \code{\link[jsonlite]{toJSON}()}}

\item{args}{Generally set to NULL (the default), in which case \code{batch()}
will call \code{\link{commandArgs}(TRUE)} to retrieve and then process
command line parameters. Alternatively, a character vector that mimics the
results from \code{\link{commandArgs}(TRUE)} can be passed for interactive
use or debugging. If present, values should be in a character vector
containing strings in the form `--<parameter>=<argument>` (or
`--<parameter>` for boolean switch).  If the character vector is named, the
names are ignored.}
}
\value{
A numeric vector with a single value: 0 if \code{fun} terminates
  successfully, 1 if \code{fun} terminates successfully with warnings, 2 if
  \code{fun} throw an error, and 3 if an error occurs in argument processing
  or reporting and no report was sent to `--report-to` (in this case a report
  will go to stderr).

  In addition, as a side effect, \code{batch()} creates a list with the
  following format:

  \verb{list(
    time = <time of report>,
    resultType = c("Success", "Warning", "Error"),
    messages = list of warning messages,
    commandLineArgs = either `args` parameter or result from commandArgs(TRUE),
    reportArgs = processed commandLineArgs controlling tryCapture() reporting,
    expressionArgs = list of remaining processed commandLineArgs (needed by `expr`),
    result = result from <expr>)}

  This list, or a JSON representation thereof, will be sent to --report-to
  destination, as described in Details.
}
\description{
\code{tryCapture()} allows any R expression to be run from the command line
in a production environment so that result can be logged or reported as part
of an automated workflow.
}
\details{
\code{tryCapture()} is based on \code{\link{tryCatch}()} except that error
handlers are predefined to report results, including errors and warnings, to
one of several destination types.  \code{tryCapture()} builds a list (the
"\emph{result list}", see Value section below) that contains the command line
parameter strings, the interpretation of those parameters, any warnings or
errors generated, and the results of \code{expr}.  The \emph{result list} can
be:
\itemize{
\item{saved as an .rdata file;}
\item{printed to stdout or stderr; or}
\item{converted to JSON and}
\itemize{
  \item{reported to a webhook or}
  \item{logged} to a JSON (text) file; optionally gzipped.}}

The following parameters, when included on the command line, will be used by
\code{tryCapture()}, and will not available in the execution environment for
\code{expr} (more on that environment below).  Instead, they control the
behavior of \code{tryCapture()} and are referred to, collectively, as
\emph{report parameters}.

\itemize{
\item{\code{--report-to=<destination>} determines how results are reported.
Values of \code{<destination>} are one of:
\itemize{
\item{the value "stdout" for reporting to stdout (the defualt);}
\item{the value "stderr" for reporting to stderr;}
\item{the URL of a webhook (staring with "http://" or "https://");}
\item{a file name (including path, if desired) for a local file; or}
\item{the name of an environment variable associated with any of the above.}
}
In the case of a file name, the result list will be saved as an `Rdata` file
using \code{\link{saveRDS}()} unless the file extension of the provided file
name is `.json` or `.json.gz`.  For `.json` and `.json.gz` files, the result
list will be converted to JSON and saved as a text file or gzipped text
file.}
\item{\code{--json=<JSON_string>}. Provides parameters using JSON.  Can
include parameters needed by \code{expr} or other parameters used by
tryCapture (e.g., \code{report-to}).  Parameters specified using JSON will
be appended to the end of the parameter list, following any other parameters
not included in the JSON parameters.  <JSON_String> must be a valid JSON
object containing key-value pairs.  To provide a parameter "foo" with a
value, use \code{"foo":"string_value"} or, for a vector,
\code{"foo":[1,2,3]}.  For a parameter switch (parameter without a value),
use \code{"foo":true}}.
\item{\code{--simulate-error=<type>}. Simulates errors for testing and
debugging. <type> is one of "args", "function", "report", or
"function/report". "args" will simulate an error in the processing of command
line arguments, "expr" an error in the expression passed to \code{expr},
"report" an error in reporting results, and "expr/report" an error in both
the expression and reporting. "expr" errors will be reported to location
specified by \code{--report-to}.  If any other error type is requested,
reporting will be to stderr (because reporting to \code{--report-to} is
precluded if an error occurs in argument processing or reporting).}
\item{\code{--simulate-warning=<type>}. Simulates warnings for testing and
debugging.  For <type> definition, see `--simulate-error`.  Unless an error
occurs in reporting, all warnings will be reported to the \code{report-to}
destination}
\item{\code{--overwrite_file}. Affects reporting to files; ignored for other
reporting destinations. When \code{--report-to} is a file name ending in
`.json` or `.json.gz`, \code{--overwrite_file} causes an existing file to be
overwritten rather than appended (the default).  When `report-to` doesn't end
in `.json` or `.json.gz`, \code{--overwrite_file} allows an existing file to
be overwritten rather than raising an error (the default), because .Rdata
files can not be appended.}}

Any argument can be associated with a stand-alone parameter on the command
line (e.g., \code{--report-to=stdout}) OR wrapped within the \code{--json}
value (e.g., \code{--json=\{"report-to":"stdout"\}} Further, the
\code{--json=<JSON_string>} is not exclusive.  It can be mixed with other
stand-alone parameters on the command line. If the same parameter name is
provided as a stand-alone parameter and in the \code{--json=<JSON_string>},
the value of the stand-alone parameter will take precedence.

Any parameter included on the command line \emph{other than} \emph{report
parameters} are termed \emph{expression parameters}.  Each \emph{expression
parameters} will be converted to R \code{\link{name}} associated with value
of parameter's argument.  Any argument associated with an \emph{expression
parameter} that contains valid JSON will be processed as such.

Any R \code{\link{name}} arising from an \emph{expression parameter}
will be contained in an execution environment where \code{expr} is
evaluated. Therefore, any expression parameters will be available for use as
a \code{\link{name}} in `expr`. See Examples, below.

Because only the expression parameters are included in the execution
environment for <expr>, \code{mget(ls())} can be used within \code{`expr`} to
create a \code{\link{list}} of all expression parameters.  See last example
in Examples, below.

To run R code from the command line directly, use

\code{Rscript -e "commandR::tryCapture(<expr>)" --<arg>=<value> --<arg>=...}

where \code{<expr>} is the code to be executed.  Alternatively, use
\code{tryCapture()} in an R script (e.g., a script file named `foo.R`) and
call the script using:

\code{Rscript foo.R --<arg>=<value> --<arg>=...}

In order to be included in the Examples section (below), examples must use
direct calls to tryCapture() (using the \code{args} parameter) from within an
active R session.  Calls from the command line can not be included in
Examples.  However, command-line-equivalents for many examples are list
\emph{in the comments} above several of the examples below.

A note on parallel processing... The safest approach is to embed
\code{mclapply} in a script called from the command prompt using
\code{Rscript} (Google "Rscript command line" for more.) Parallel processing
using \code{mclapply} to call \code{batch} from within Rstudio often works,
but can cause Rstudio to freeze (seeminly when the screen saver engages??).
In this case, batch processing usually proceeds successfully even after
RStudio is frozen, but RStudio must be terminated manually, potentially
leading to loss of code.
}
\examples{
# Simulate following command line:
#
# > Rscript -e "commandR::tryCapture(log(x,base))" --json='{"x":[1,5,10], "base":[10], "report-to":"stdout"}'
#
# This is the most reliable way to use tryCapture because all values are typed
# and JSON arrays and objects can be used to create parameters that become R
# vectors and lists.
tryCapture(log(x, base), args = '--json={"x":[1,5,10], "base":[10], "report-to":"stdout"}')

# Simulate following command line (yields exact same result as above but mixes
# stand-alone paramter with --json):
#
# > Rscript -e "commandR::tryCapture(log(x,base))" --report-to=stdout --json='{"x":[1,5,10], "base":[10]}'
#
tryCapture(log(x, base), args = c('--report-to=stdout', '--json={"x":[1,5,10], "base":[10]}'))

# Use only direct parameters:
#
# > Rscript -e "commandR::tryCapture(log(x,base))" --x=1,5,10 --base=10 --report-to=stdout
#
# This yields an error because direct command line parameters are always passed
# as strings and `log()` can not accept strings.  Notice, however, the error
# is capture and reported with a stack trace as part of the result list.
tryCapture(log(x, base), args = c("--x=1,5,10", "--base=10", "--report-to=stdout"))

# Direct command line parameters *can* be used, however,  writing a wrapper for
# `log()` See commandArgs::batch_log() as an example of such a wrapper:
body(commandR::batch_log)

# Using batch_log() rather than log(), the command line with only direct
# parameters works just fine.
#
# > Rscript -e "commandR::tryCapture(batch_log(x,base))" --x=1,5,10 --base=10 --report-to=stdout
#
tryCapture(batch_log(x, base), args = c("--x=1,5,10", "--base=10", "--report-to=stdout"))

# As demonstrated above, errors that occur in the expression passed to
# tryCapture will be reported to location specified by `--report-to`. To test
# error recovery in any larger pipeline that uses tryCapture, you can simulate
# an error or warning in an expression using the `--simulate-warning` and
# `--simulate-error` flags.  These conditions will be included in the "messages"
# member of the results list and sent to the `report-to` destination.  Error
# level 1 is returned for warnings, 2 for errors.
#
# > Rscript -e "commandR::tryCapture(log(x,base))" --json='{"x":[1,5,10], "base":[10], "report-to":"stdout", "simulate-warning":"expr"}'
# > Rscript -e "commandR::tryCapture(log(x,base))" --json='{"x":[1,5,10], "base":[10], "report-to":"stdout", "simulate-error":"expr"}'
#
tryCapture(
  log(x, base),
  args = '--json={"x":[1,5,10], "base":[10], "report-to":"stdout", "simulate-warning":"expr"}')

tryCapture(
  log(x, base),
  args = '--json={"x":[1,5,10], "base":[10], "report-to":"stdout", "simulate-error":"expr"}')

# However, unrecoverable errors can occur during argument parsing (meaning the
# report-to destination is not known) or during reporting (so the result list is
# not sent to the report-to destination). In either case, the result list,
# including warning and error reports, will be redirected to stderr and an error
# level of 3 is returned.  These types of condition can be simulated with
# `--simulate_error=args` or `--simulate_error=report` (If you click "Run
# examples" in the help file to execute the examples below, anything reported to
# stderr appears in the **console** and the stack trace is quite large...  These
# two examples might be best run by pasting into the console.)
tryCapture(
  log(x, base),
  args = '--json={"x":[1,5,10], "base":[10], "report-to":"stdout", "simulate-error":"args"}')

tryCapture(
  log(x, base),
  args = '--json={"x":[1,5,10], "base":[10], "report-to":"stdout", "simulate-error":"report"}')

# Finally, `mget(ls()` can be used in `expr` to create list of all expression
# parameters.
tryCapture(
  as.data.frame( mget(ls()) ),
  args = '--json={"x":[1,5,10], "y":[2,4,6], "z":[2,3,4], "report-to":"stdout"}')
}
